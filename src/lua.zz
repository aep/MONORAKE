using <stdio.h>::{printf};
using <stdlib.h>::{free, realloc};
using "../3rp/lua-5.3.5/src/lua.h" as lua;
using "../3rp/lua-5.3.5/src/lualib.h" as lual;
using "../3rp/lua-5.3.5/src/lauxlib.h" as luax;

using string;
using err;

export struct Context {
    lua::lua_State mut* l;
}


export fn alloc_for_lua (void mut *ud, void mut *ptr, usize osize, usize nsize) -> void mut*
{
    if (nsize == 0) {
        free(ptr);
        return 0;
    } else {
        return realloc(ptr, nsize);
    }
}

pub fn create(Context new mut *self) {
	self->l = (lua::lua_State mut*)lua::lua_newstate(alloc_for_lua,0);
    lual::luaL_openlibs(self->l);
}



export symbol LuaError;



pub fn set(Context mut *self, err::Err+et mut*e, char *k, char *v)
    where err::checked(*e)
    where nullterm(k)
    where nullterm(v)
{
    lua::lua_pushstring(self->l, v);
    lua::lua_setglobal(self->l, k);
}

pub fn run(Context *self, err::Err+et mut*e, char *code, usize l) -> char*
    where err::checked(*e)
    where len(code) >= l
{

    new+3000 buf = string::make();
    buf.append_cstr("return ");
    buf.append_bytes((u8*)code, l);
    buf.append_cstr(";");

    if luax::luaL_loadbuffer (self->l, buf.cstr(), buf.slen(), "inline") != 0 {
        err::fail(e, LuaError, "%s", lua::lua_tostring(self->l, -1));
        return 0;
    }
    if lua::lua_pcall(self->l, 0, 1, 0) != 0 {
        err::fail(e, LuaError, "%s", lua::lua_tostring(self->l, -1));
        return 0;
    }

    char *s = (char*)lua::lua_tostring(self->l, -1);
    return s;
}

pub fn close(Context mut *self) {
	lua::lua_close(self->l);
}
